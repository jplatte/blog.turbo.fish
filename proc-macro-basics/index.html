<!doctype html>
<html lang="en" class="index">

<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="blog.turbo.fish">

<meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'none';
    style-src 'self' 'unsafe-inline';
    frame-src 'none'
    
">

<title>Procedural Macros: The Basics | blog.turbo.fish</title>

<link rel="stylesheet" href="/normalize.css">
<link rel="stylesheet" href="/blog.css">

<div class="page">
    <div class="content">
        

<article>
    <h1 class="page-title">Procedural Macros: The Basics</h1>
    <small class="post-meta">
        Published
        <time datetime="2021-02-16">2021-02-16</time>
        on
        <a href="/">blog.turbo.fish</a>
    </small>
    
    <p>Procedural macros (often shortened to "proc-macros") are a unique Rust feature
that allow creating custom derives, attributes and function-like macros in
regular Rust code that is run at compile time. And although they are the only
way of writing custom attributes and derives, vastly more powerful and even
easier to read than (large) declarative macros, there is very little learning
material out there for proc-macros.</p>
<p>That's why I'm here, writing my own blog series on the matter. Currently, I plan
to write 5 more posts after this one, starting with a very basic derive example
that should appear within a week or two, continuing with a discussion on
proc-macro error handling and then moving to topics only applicable to smaller
subsets of proc-macros.</p>
<h2 id="anatomy-of-a-procedural-macro">Anatomy of a procedural macro</h2>
<p>Procedural macros are functions with a <code>#[proc_macro]</code>,
<code>#[proc_macro_derive(Name)]</code> or <code>#[proc_macro_attribute]</code> attribute. They have
one (function-like and derive macros) or two (attribute macros)
<code>proc_macro::TokenStream</code> arguments and also return a <code>proc_macro::TokenStream</code>.</p>
<blockquote>
<p>You can sort of think of procedural macros as functions from an AST to another
AST.</p>
<p>— <a href="https://doc.rust-lang.org/reference/procedural-macros.html">The Rust Reference</a></p>
</blockquote>
<p>They must be public (<code>pub fn ...</code>) and live in a crate of the type <code>proc-macro</code>.
When using Cargo (and who doesn't?) this crate type is declared
in the <code>lib</code> section of <code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#808080;">lib</span><span>]
</span><span style="color:#569cd6;">proc-macro </span><span>= </span><span style="color:#569cd6;">true
</span></code></pre>
<p>A proc-macro crate can <em>only</em> export proc-macros, no regular functions, types,
modules or <code>macro_rules!</code> macros. It can of course define other items, but it
cannot export them for use in other crates.</p>
<h2 id="the-crates-involved">The crates involved</h2>
<p>Every proc-macro crate can access the builtin <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code> crate</a>.
There is not much to say about it; the only type from it that a typical
proc-macro interacts with is <code>proc_macro::TokenStream</code>.</p>
<p>All of the following articles are going to be about proc-macros that parse their
input with <code>syn</code> and generate their output with <code>quote</code>. These are not mandatory
for proc-macros, but they are used by the vast majority of them.</p>
<p><a href="https://docs.rs/syn/1.0">syn</a> focuses on parsing Rust code into its own <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>, but also has (optional)
support for parsing custom syntax, which can be very useful when parsing
attributes, function-like macro input or custom syntax embedded into Rust syntax
(most commonly when writing attribute macros).</p>
<p><a href="https://docs.rs/quote/1.0">quote</a> has a tiny API surface of which one item sees the vast majority of
<code>use</code>s: <code>quote!</code>. <code>quote!</code> is a function-like macro that turns its input into a
<code>proc_macro2::TokenStream</code> while substituting placeholders. If you have read or
written a <code>macro_rules!</code> macro before, I'll already let you know this:
<code>quote! { #(#key: #value),* }</code> is the proc-macro equivalent to
<code>$($key: $value),*)</code>. If you haven't, don't mind the symbol soup above: We'll
get to that in the next article.</p>
<div class="info">
<p>You might be wondering about the <code>2</code> in <code>proc_macro2</code> above. It's not a typo,
syn and quote actually hardly interact with the types from the builtin
<code>proc_macro</code> crate directly, instead using the wrapper crate <a href="https://docs.rs/proc-macro2/1.0">proc-macro2</a>. This
crate only exist because the builtin crate is limited to procedural macro
compilation contexts. For more details, see the linked documentation.</p>
</div>
<h2 id="derive-macros-vs-attribute-macros">Derive macros vs. attribute macros</h2>
<p>One important difference between derive macros and attribute macros that I only
learned about rather late myself is that derive macros generate code that is
then <em>added</em> to the same module, while attribute macros generate code that
<em>replaces</em> the item they were applied on.</p>
<p>This makes a lot of sense when you consider the use cases for each: derive
macros are only really meant to add <code>impl</code> blocks and nothing else. For
attribute macros this is much less clear, for example one might want to create
an attribute macro that introduces a new control-flow operator. Clearly the
code can only compile successfully if that kind of thing is stripped as part of
macro expansion, which also brings me to:</p>
<h2 id="a-note-on-macro-expansion">A note on macro expansion</h2>
<p>I have seen people from time to time being surprised or sometimes confused about
what macros, proc-macros in particular, are capable of but also what they're
<em>not</em> capable of.</p>
<p>I think this is most often a cause of not knowing or not considering how macros
interact with the compiler, i.e. how the compiler expands them: Macros have
input and output tokens, but can't "talk to the compiler" beyond that simple
interface. This means they can't do things like inspecting the outer scope of
source code in which they were invoked, or figure out where names referenced in
their input are coming from.</p>
<p>One real-world case where I've seen this be a problem (or maybe more of an
annoyance) is <a href="https://docs.rs/thiserror/1.0">thiserror</a>. It derives <code>std</code>s <code>Error</code> trait for the user,
including the unstable¹ <code>backtrace()</code> method if there is a field with a type
named <code>Backtrace</code>. If you want to capture backtraces on stable using the
<a href="https://docs.rs/backtrace/0.3">backtrace</a> crate and also use the <code>thiserror::Error</code> derive macro for your
error type, you have to rename the <code>Backtrace</code> type at the import site, or you
get stability errors because thiserror tries to implement an unstable method for
you.</p>
<h2 id="next-up">Next up</h2>
<p>The next article is going to explain how to implement a basic derive macro.
You can find it at the 'Next post' link below.</p>
<p>[^1] at the time of writing</p>

</article>

<ul class="other-post-links">
    
    <li class="previous-post">
        <small>Previous post</small>
        <a href="https:&#x2F;&#x2F;blog.turbo.fish&#x2F;cargo-features&#x2F;">Advanced Cargo [features] Usage</a>
    </li>
    
    
    <li class="next-post">
        <small>Next post</small>
        <a href="https:&#x2F;&#x2F;blog.turbo.fish&#x2F;proc-macro-simple-derive&#x2F;">Procedural Macros: A simple derive macro</a>
    </li>
    
</ul>


        <div class="bg" aria-hidden="true" tabindex="-1">
        
            <t><​></t>
            <u><​></u>
            <r><​></r>
            <b><​></b>
            <o><​></o>
            <f><​></f>
            <i><​></i>
            <s><​></s>
            <h><​></h>
        
            <t><​></t>
            <u><​></u>
            <r><​></r>
            <b><​></b>
            <o><​></o>
            <f><​></f>
            <i><​></i>
            <s><​></s>
            <h><​></h>
        
            <t><​></t>
            <u><​></u>
            <r><​></r>
            <b><​></b>
            <o><​></o>
            <f><​></f>
            <i><​></i>
            <s><​></s>
            <h><​></h>
        
            <t><​></t>
            <u><​></u>
            <r><​></r>
            <b><​></b>
            <o><​></o>
            <f><​></f>
            <i><​></i>
            <s><​></s>
            <h><​></h>
        
            <t><​></t>
            <u><​></u>
            <r><​></r>
            <b><​></b>
            <o><​></o>
            <f><​></f>
            <i><​></i>
            <s><​></s>
            <h><​></h>
        
        </div>
    </div>

    <aside class="sidebar">
    <small>This blog is written by</small>
    <div class="author">
        <img class="author-icon" src="&#x2F;img&#x2F;jplatte.png" alt="">
        <span class="author-name">Jonas Platte</span>
    </div>

    <div class="about">
        <p>I am the creator of <a href="https://turbo.fish/">turbo.fish</a> and <a href="https://caniuse.rs/">caniuse.rs</a>. You may also know me
because of my involvement with the <a href="https://ruma.dev/">Ruma</a> project.</p>

    </div>

    <ul class="ext-links">
    
        <li>
            <small>sourcehut</small><br>
            <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~jplatte&#x2F;">~jplatte</a>
        </li>
    
        <li>
            <small>github</small><br>
            <a href="https:&#x2F;&#x2F;github.com&#x2F;jplatte">jplatte</a>
        </li>
    
        <li>
            <small>liberapay</small><br>
            <a href="https:&#x2F;&#x2F;liberapay.com&#x2F;jplatte&#x2F;">jplatte</a>
        </li>
    
    </ul>

    <div class="rss">
        <a href="/rss.xml"><svg viewBox="0 0 1536 1536" width="13" height="13" xmlns="http://www.w3.org/2000/svg">
    <title>News feed (Atom)</title>
    <path d="M384 1344c0 106-86 192-192 192S0 1450 0 1344s86-192 192-192 192 86 192 192zm512 123c1 18-5 35-17 48-12 14-29 21-47 21H697c-33 0-60-25-63-58-29-305-271-547-576-576-33-3-58-30-58-63V704c0-18 7-35 21-47 11-11 27-17 43-17h5c213 17 414 110 565 262 152 151 245 352 262 565zm512 2c1 17-5 34-18 47-12 13-28 20-46 20h-143c-34 0-62-26-64-60C1104 895 641 432 60 398c-34-2-60-30-60-63V192c0-18 7-34 20-46 12-12 28-18 44-18h3c350 18 679 165 927 414 249 248 396 577 414 927z"/>
</svg>RSS Feed</a>
    </div>

    <div class="sidebar-footer">
        <small>Built using <a href="https://www.getzola.org/">Zola</a></small>
    </div>
</aside>

</div>

</html>
